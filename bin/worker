#!/usr/bin/env python

"""

Test contract address: 0xF0cb6b45a902d2aa225305E5F0b920eb3D81c42B

"""

import json
import getpass
import argparse
import logging
import sys

from cpc_fusion import Web3

DEFAULT_ENDPOINT = 'https://civilian.cpchain.io'

logging.basicConfig(stream=sys.stdout, level=logging.INFO,
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
log = logging.getLogger()

# args parser
parser = argparse.ArgumentParser()


def get_cf(args):
    # web3 client
    cf = Web3(Web3.HTTPProvider(args.endpoint))
    return cf


def get_instance(cf, args):
    with open(args.contract_file, 'r') as fr:
        contract_data = json.load(fr)
    instance = cf.cpc.contract(
        abi=contract_data['abi'], address=args.contract_addr)
    return instance


def load_keystore(cf, args):
    keystorePath = args.keystore
    with open(keystorePath, 'r') as fr:
        ks = json.load(fr)
        addr = cf.toChecksumAddress(ks['address'])
        return ks, addr


def submit_tx(cf, ks, tx):
    password = getpass.getpass("Please input your password: ")
    decrypted_key = cf.cpc.account.decrypt(ks, password)
    password = ""
    signed_txn = cf.cpc.account.signTransaction(tx, decrypted_key)
    tx_hash = cf.cpc.sendRawTransaction(signed_txn.rawTransaction)
    receipt = cf.cpc.waitForTransactionReceipt(tx_hash)
    if receipt.status == 0:
        print(receipt)
        log.info('Sorry, failed.')
    else:
        log.info('Success')
    return receipt


def refund(args):
    """ withdraw
    """
    cf = get_cf(args)
    contract = get_instance(cf, args)
    to = cf.toChecksumAddress(args.to)

    # build tx
    ks, addr = load_keystore(cf, args)
    gas_price = cf.cpc.gasPrice
    nonce = cf.cpc.getTransactionCount(addr)
    tx = contract.functions.refund(to).buildTransaction({
        'gasPrice': gas_price,
        "nonce": nonce,
        "gas": 300000,
        "from": addr,
        "value": cf.toWei(args.value, 'ether'),
        "type": 0,
        "chainId": 337
    })

    # send tx
    receipt = submit_tx(cf, ks, tx)

    if receipt.status != 0:
        events = contract.events['RefundMoney']().createFilter(
            fromBlock=receipt.blockNumber).get_all_entries()
        for e in events:
            value = cf.fromWei(e.args['amount'], 'ether')
            log.info(
                f"Refund to: {e.args['addr']}, value: {value}")


def get_balance(args):
    cf = get_cf(args)
    instance = get_instance(cf, args)
    addr = cf.toChecksumAddress(args.address)

    # address
    balance = cf.fromWei(instance.functions.balanceOf(addr).call(), 'ether')
    withdrawnBalance = cf.fromWei(
        instance.functions.getWithdrawnBalance(addr).call(), 'ether')
    appealedBalance = cf.fromWei(
        instance.functions.getAppealedBalance(addr).call(), 'ether')
    interest = cf.fromWei(instance.functions.getInterest(addr).call(), 'ether')

    log.info('Balance: %s', balance)
    log.info('Withdrawn Balance: %s', withdrawnBalance)
    log.info('Appealed Balance: %s', appealedBalance)
    log.info('Interest: %s', interest)


def build_parser(subparsers, name, func=None, helps="Help", keystore=False,
                 contract_file=False, endpoint=False, contract_address=False):
    parser = subparsers.add_parser(name, help=helps)
    if keystore:
        parser.add_argument('--keystore', required=True)
    if contract_file:
        parser.add_argument('--contract-file', required=True)
    if endpoint:
        parser.add_argument('--endpoint', type=str, default=DEFAULT_ENDPOINT)
    if contract_address:
        parser.add_argument('--contract-addr', type=str, required=True)
    parser.set_defaults(func=func)
    return parser


subparsers = parser.add_subparsers(help="sub-command help")

# refund
refund_parser = build_parser(subparsers, 'refund', refund, 'refund money',
                              keystore=True, contract_file=True, endpoint=True, contract_address=True)
refund_parser.add_argument('--to', type=str, required=True)
refund_parser.add_argument('value', type=int)

# balance
balance_parser = build_parser(subparsers, 'get-balance', get_balance, 'get balance',
                              contract_file=True, endpoint=True, contract_address=True)
balance_parser.add_argument('address', type=str)

args = parser.parse_args()

if len(args.__dict__) <= 1:
    # No arguments or subcommands were given.
    parser.print_help()
    parser.exit()

args.func(args)
