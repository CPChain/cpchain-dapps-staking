#!/usr/bin/env python3

"""

Test contract address: 0xF0cb6b45a902d2aa225305E5F0b920eb3D81c42B

"""

import json
import getpass
import argparse
import logging
import sys
import os
import time
import threading
import queue

from cpc_fusion import Web3

DEFAULT_ENDPOINT = 'https://civilian.cpchain.io'

logging.basicConfig(stream=sys.stdout, level=logging.INFO,
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
log = logging.getLogger()

# args parser
parser = argparse.ArgumentParser()

class dotdict(dict):
    """dot.notation access to dictionary attributes"""
    __getattr__ = dict.get
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__


def get_cf(args):
    # web3 client
    cf = Web3(Web3.HTTPProvider(args.endpoint))
    return cf


def get_instance(cf, args):
    with open(args.contract_file, 'r') as fr:
        contract_data = json.load(fr)
    instance = cf.cpc.contract(
        abi=contract_data['abi'], address=args.contract_addr)
    return instance


def load_keystore(cf, args):
    keystorePath = args.keystore
    with open(keystorePath, 'r') as fr:
        ks = json.load(fr)
        addr = cf.toChecksumAddress(ks['address'])
        return ks, addr


def submit_tx(cf, ks, tx):
    password = getpass.getpass("Please input your password: ")
    decrypted_key = cf.cpc.account.decrypt(ks, password)
    password = ""
    signed_txn = cf.cpc.account.signTransaction(tx, decrypted_key)
    tx_hash = cf.cpc.sendRawTransaction(signed_txn.rawTransaction)
    receipt = cf.cpc.waitForTransactionReceipt(tx_hash)
    if receipt.status == 0:
        print(receipt)
        log.info('Sorry, failed.')
    else:
        log.info('Success')
    return receipt


def refund(args):
    """ withdraw
    """
    cf = get_cf(args)
    contract = get_instance(cf, args)
    to = cf.toChecksumAddress(args.to)

    # build tx
    ks, addr = load_keystore(cf, args)
    gas_price = cf.cpc.gasPrice
    nonce = cf.cpc.getTransactionCount(addr)
    tx = contract.functions.refund(to).buildTransaction({
        'gasPrice': gas_price,
        "nonce": nonce,
        "gas": 300000,
        "from": addr,
        "value": cf.toWei(args.value, 'ether'),
        "type": 0,
        "chainId": 337
    })

    # send tx
    receipt = submit_tx(cf, ks, tx)

    if receipt.status != 0:
        events = contract.events['RefundMoney']().createFilter(
            fromBlock=receipt.blockNumber).get_all_entries()
        for e in events:
            value = cf.fromWei(e.args['amount'], 'ether')
            log.info(
                f"Refund to: {e.args['addr']}, value: {value}")


def get_balance(args):
    cf = get_cf(args)
    instance = get_instance(cf, args)
    addr = cf.toChecksumAddress(args.address)

    # address
    balance = cf.fromWei(instance.functions.workerBalanceOf(addr).call(), 'ether')
    interest = cf.fromWei(instance.functions.getWorkerInterest(addr).call(), 'ether')

    log.info('Balance: %s', balance)
    log.info('Interest: %s', interest)


def handler(q, cf, instance, decrypted_key, addr):
    while True:
        e = q.get()
        value = cf.fromWei(e.args['value'], 'ether')
        selected = e.args['selectedWorker']
        to = e.args['account']
        log.info(f"slected worker: {selected.lower()}")
        if selected.lower() == addr.lower():
            log.info(
                f"Selected worker: {selected}, value: {value}, start to refund")
            gas_price = cf.cpc.gasPrice
            nonce = cf.cpc.getTransactionCount(addr)
            tx = instance.functions.refund(to).buildTransaction({
                'gasPrice': gas_price,
                "nonce": nonce,
                "gas": 300000,
                "from": addr,
                "value": cf.toWei(value, 'ether'),
                "type": 0,
                "chainId": 337
            })

            # send tx
            signed_txn = cf.cpc.account.signTransaction(tx, decrypted_key)
            tx_hash = cf.cpc.sendRawTransaction(signed_txn.rawTransaction)
            receipt = cf.cpc.waitForTransactionReceipt(tx_hash)
            if receipt.status == 0:
                print(receipt)
                log.info('Sorry, refund failed.')
            else:
                log.info('Refund success')
        q.task_done()


def run(args):
    cf = get_cf(args)
    instance = get_instance(cf, args)
    ks, addr = load_keystore(cf, args)

    # read password
    with open(args.password, 'r') as f:
        password = "".join(f.readlines())
    password = password.strip()
    decrypted_key = cf.cpc.account.decrypt(ks, password)
    
    q = queue.Queue()

    threading.Thread(target=handler, args=(q, cf, instance, decrypted_key, addr), daemon=True).start()

    # read .worker.json
    FILE_NAME = '.worker.json'
    context = dotdict({'fromBlock': 5953500 })
    if os.path.exists(FILE_NAME):
        with open(FILE_NAME, 'r') as f:
            context = json.load(f)
    
    context = dotdict(context)

    # Listen the withdraw event from the start block
    while True:
        log.info("#Block %d", context.fromBlock)
        events = instance.events['Withdraw']().createFilter(
            fromBlock=context.fromBlock).get_all_entries()
        for e in events:
            q.put(e)
            context.fromBlock = e['blockNumber']
        if cf.cpc.blockNumber <= context.fromBlock:
            current = cf.cpc.blockNumber
            while current == cf.cpc.blockNumber:
                time.sleep(0.1)
            context.fromBlock = cf.cpc.blockNumber
        else:
            context.fromBlock += 1
        with open(FILE_NAME, 'w') as f:
            f.write(json.dumps(context))


def build_parser(subparsers, name, func=None, helps="Help", keystore=False,
                 contract_file=False, endpoint=False, contract_address=False):
    parser = subparsers.add_parser(name, help=helps)
    if keystore:
        parser.add_argument('--keystore', required=True)
    if contract_file:
        parser.add_argument('--contract-file', required=True)
    if endpoint:
        parser.add_argument('--endpoint', type=str, default=DEFAULT_ENDPOINT)
    if contract_address:
        parser.add_argument('--contract-addr', type=str, required=True)
    parser.set_defaults(func=func)
    return parser


subparsers = parser.add_subparsers(help="sub-command help")

# refund
refund_parser = build_parser(subparsers, 'refund', refund, 'refund money',
                              keystore=True, contract_file=True, endpoint=True, contract_address=True)
refund_parser.add_argument('--to', type=str, required=True)
refund_parser.add_argument('value', type=int)

# balance
balance_parser = build_parser(subparsers, 'get-balance', get_balance, 'get balance',
                              contract_file=True, endpoint=True, contract_address=True)
balance_parser.add_argument('address', type=str)

# run
run_parser = build_parser(subparsers, 'run', run, 'run',
                              keystore=True, contract_file=True, endpoint=True, contract_address=True)
run_parser.add_argument('--password', type=str, required=True)

args = parser.parse_args()

if len(args.__dict__) <= 1:
    # No arguments or subcommands were given.
    parser.print_help()
    parser.exit()

args.func(args)
