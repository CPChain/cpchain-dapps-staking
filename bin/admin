#!/usr/bin/env python

"""

Test contract address: 0xF0cb6b45a902d2aa225305E5F0b920eb3D81c42B

"""

import json
import getpass
import argparse
import logging
from os import remove
import sys

from cpc_fusion import Web3

DEFAULT_ENDPOINT = 'https://civilian.cpchain.io'

logging.basicConfig(stream=sys.stdout, level=logging.INFO,
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
log = logging.getLogger()

# args parser
parser = argparse.ArgumentParser()


def get_cf(args):
    # web3 client
    cf = Web3(Web3.HTTPProvider(args.endpoint))
    return cf


def get_contract(cf, args):
    # load contract
    with open(args.contract_file, 'r') as fr:
        contract_data = json.load(fr)
    contract = cf.cpc.contract(
        abi=contract_data['abi'], bytecode=contract_data['bytecode'])
    return contract, 'Staking'


def get_instance(cf, args):
    with open(args.contract_file, 'r') as fr:
        contract_data = json.load(fr)
    instance = cf.cpc.contract(
        abi=contract_data['abi'], address=args.contract_addr)
    return instance


def load_keystore(cf, args):
    keystorePath = args.keystore
    with open(keystorePath, 'r') as fr:
        ks = json.load(fr)
        addr = cf.toChecksumAddress(ks['address'])
        return ks, addr


def submit_tx(cf, ks, tx):
    password = getpass.getpass("Please input your password: ")
    decrypted_key = cf.cpc.account.decrypt(ks, password)
    password = ""
    signed_txn = cf.cpc.account.signTransaction(tx, decrypted_key)
    tx_hash = cf.cpc.sendRawTransaction(signed_txn.rawTransaction)
    receipt = cf.cpc.waitForTransactionReceipt(tx_hash)
    if receipt.status == 0:
        print(receipt)
        log.info('Sorry, failed.')
    else:
        log.info('Success')


def deploy(args):
    """ deploy contract
    """
    cf = get_cf(args)

    contract, name = get_contract(cf, args)

    # build tx
    keystorePath = args.keystore
    with open(keystorePath, 'r') as fr:
        ks = json.load(fr)
        addr = cf.toChecksumAddress(ks['address'])
    gas_price = cf.cpc.gasPrice
    nonce = cf.cpc.getTransactionCount(addr)
    estimated_gas = contract.constructor().estimateGas()
    tx = contract.constructor().buildTransaction({
        'gasPrice': gas_price,
        "nonce": nonce,
        "gas": estimated_gas,
        "from": addr,
        "value": cf.toWei(0, 'ether'),
        "type": 0,
        "chainId": 337
    })

    # send tx
    password = getpass.getpass("Please input your password:")
    decrypted_key = cf.cpc.account.decrypt(ks, password)
    password = ""
    signed_txn = cf.cpc.account.signTransaction(tx, decrypted_key)
    tx_hash = cf.cpc.sendRawTransaction(signed_txn.rawTransaction)

    # get tx receipt to get contract address
    tx_receipt = cf.cpc.waitForTransactionReceipt(tx_hash)
    address = tx_receipt['contractAddress']
    print(f'{name} Address: {address}')
    return address


def show_configs(args):
    cf = get_cf(args)
    contract = get_instance(cf, args)
    # show configs
    enable = contract.functions.enabled().call()
    withdraw_fee_numerator = contract.functions.withdraw_fee_numerator().call()
    withdraw_fee_denominator = contract.functions.withdraw_fee_denominator().call()
    worker_balance_limit = contract.functions.worker_balance_limit().call()
    user_balance_limit = contract.functions.user_balance_limit().call()
    tx_upper_limit = contract.functions.tx_upper_limit().call()
    tx_lower_limit = contract.functions.tx_lower_limit().call()
    withdraw_upper_limit = contract.functions.withdraw_upper_limit().call()
    print('=' * 20)
    print("Enable:", enable)
    print("Withdraw Fee Numerator:", withdraw_fee_numerator)
    print("Withdraw Fee Denominator:", withdraw_fee_denominator)
    print("Worker Balance Limit:", worker_balance_limit)
    print("User Balance Limit:", user_balance_limit)
    print("Tx Upper Limit:", tx_upper_limit)
    print("Tx Lower Limit:", tx_lower_limit)
    print("Withdraw Upper Limit:", withdraw_upper_limit)
    print('=' * 20)
    print("Worker's cnt:", contract.functions.workersCnt().call())


def add_worker(args):
    """ Add a worker
    """
    cf = get_cf(args)
    instance = get_instance(cf, args)
    worker_addr = cf.toChecksumAddress(args.worker)
    gas_price = cf.cpc.gasPrice

    ks, addr = load_keystore(cf, args)

    nonce = cf.cpc.getTransactionCount(addr)
    tx = instance.functions.addWorker(worker_addr).buildTransaction({
        'gasPrice': gas_price,
        "nonce": nonce,
        "gas": 300000,
        "from": addr,
        "value": 0,
        "type": 0,
        "chainId": 337
    })
    submit_tx(cf, ks, tx)


def remove_worker(args):
    """ Remove a worker
    """
    cf = get_cf(args)
    instance = get_instance(cf, args)
    worker_addr = cf.toChecksumAddress(args.worker)
    gas_price = cf.cpc.gasPrice

    ks, addr = load_keystore(cf, args)

    nonce = cf.cpc.getTransactionCount(addr)
    tx = instance.functions.removeWorker(worker_addr).buildTransaction({
        'gasPrice': gas_price,
        "nonce": nonce,
        "gas": 300000,
        "from": addr,
        "value": 0,
        "type": 0,
        "chainId": 337
    })
    submit_tx(cf, ks, tx)

def is_worker(args):
    pass

def stats_interest(args):
    pass


def appeal_refund(args):
    pass


def monitoring(args):
    """
    Monitoring the event for appeal
    """
    pass


def build_parser(subparsers, name, func=None, helps="Help", keystore=False,
                 contract_file=False, endpoint=False, contract_addr=False):
    parser = subparsers.add_parser(name, help=helps)
    if keystore:
        parser.add_argument('--keystore', required=True)
    if contract_file:
        parser.add_argument('--contract-file', required=True)
    if endpoint:
        parser.add_argument('--endpoint', type=str, default=DEFAULT_ENDPOINT)
    if contract_addr:
        parser.add_argument('--contract-addr', type=str)
    parser.set_defaults(func=func)
    return parser


subparsers = parser.add_subparsers(help="sub-command help")

# deploy
build_parser(subparsers, 'deploy', deploy, 'deploy contract',
             keystore=True, contract_file=True, endpoint=True)

# show-configs
build_parser(subparsers, 'show-configs', show_configs, 'show configurations',
             contract_file=True, contract_addr=True, endpoint=True)

# add-worker
add_worker_parser = build_parser(subparsers, 'add-worker', helps='add worker', keystore=True,
                                 contract_file=True, contract_addr=True, endpoint=True)
add_worker_parser.add_argument('worker', type=str)

# remove worker
remove_worker_parser = build_parser(subparsers, 'remove-worker', func=remove_worker, helps='remove worker', keystore=True,
                                    contract_file=True, contract_addr=True, endpoint=True)
remove_worker_parser.add_argument('worker', type=str)

args = parser.parse_args()

if len(args.__dict__) <= 1:
    # No arguments or subcommands were given.
    parser.print_help()
    parser.exit()

args.func(args)
