#!/usr/bin/env python

"""

Test contract address: 0xF0cb6b45a902d2aa225305E5F0b920eb3D81c42B

"""

import json
import getpass
import argparse
import logging
import os
from os import remove
import sys

from cpc_fusion import Web3

DEFAULT_ENDPOINT = 'https://civilian.cpchain.io'

FILE_NAME = ".staking.json"

EVENT_ADD_WORKER = 'AddWorker'
EVENT_REMOVE_WORKER = 'RemoveWorker'


class dotdict(dict):
    """dot.notation access to dictionary attributes"""
    __getattr__ = dict.get
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__


logging.basicConfig(stream=sys.stdout, level=logging.INFO,
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
log = logging.getLogger()

# args parser
parser = argparse.ArgumentParser()


def load_data():
    if not os.path.exists(FILE_NAME):
        return {}
    with open(FILE_NAME, 'r') as fr:
        return json.load(fr)


context = dotdict(load_data())


def get_cf(args):
    # web3 client
    cf = Web3(Web3.HTTPProvider(args.endpoint))
    return cf


def get_contract(cf, args):
    # load contract
    with open(args.contract_file, 'r') as fr:
        contract_data = json.load(fr)
    contract = cf.cpc.contract(
        abi=contract_data['abi'], bytecode=contract_data['bytecode'])
    return contract, 'Staking'


def get_instance(cf, args):
    with open(args.contract_file, 'r') as fr:
        contract_data = json.load(fr)
    instance = cf.cpc.contract(
        abi=contract_data['abi'], address=context.address)
    return instance


def load_keystore(cf, args):
    keystorePath = args.keystore
    with open(keystorePath, 'r') as fr:
        ks = json.load(fr)
        addr = cf.toChecksumAddress(ks['address'])
        return ks, addr


def submit_tx(cf, ks, tx):
    password = getpass.getpass("Please input your password: ")
    decrypted_key = cf.cpc.account.decrypt(ks, password)
    password = ""
    signed_txn = cf.cpc.account.signTransaction(tx, decrypted_key)
    tx_hash = cf.cpc.sendRawTransaction(signed_txn.rawTransaction)
    receipt = cf.cpc.waitForTransactionReceipt(tx_hash)
    if receipt.status == 0:
        print(receipt)
        log.info('Sorry, failed.')
    else:
        log.info('Success')


def deploy(args):
    """ deploy contract
    """
    cf = get_cf(args)

    contract, name = get_contract(cf, args)

    # build tx
    keystorePath = args.keystore
    with open(keystorePath, 'r') as fr:
        ks = json.load(fr)
        addr = cf.toChecksumAddress(ks['address'])
    gas_price = cf.cpc.gasPrice
    nonce = cf.cpc.getTransactionCount(addr)
    estimated_gas = contract.constructor().estimateGas()
    tx = contract.constructor().buildTransaction({
        'gasPrice': gas_price,
        "nonce": nonce,
        "gas": estimated_gas,
        "from": addr,
        "value": cf.toWei(0, 'ether'),
        "type": 0,
        "chainId": 337
    })

    # send tx
    password = getpass.getpass("Please input your password:")
    decrypted_key = cf.cpc.account.decrypt(ks, password)
    password = ""
    signed_txn = cf.cpc.account.signTransaction(tx, decrypted_key)
    tx_hash = cf.cpc.sendRawTransaction(signed_txn.rawTransaction)

    # get tx receipt to get contract address
    tx_receipt = cf.cpc.waitForTransactionReceipt(tx_hash)
    address = tx_receipt['contractAddress']
    print(f'{name} Address: {address}')
    context['address'] = address
    context['fromBlock'] = tx_receipt.blockNumber
    return address

def to_cpc(cf, value):
    return cf.fromWei(value, 'ether')


def show_configs(args):
    cf = get_cf(args)
    contract = get_instance(cf, args)
    # show configs
    enable = contract.functions.enabled().call()
    withdraw_fee_numerator = contract.functions.withdraw_fee_numerator().call()
    withdraw_fee_denominator = contract.functions.withdraw_fee_denominator().call()
    worker_balance_limit = to_cpc(cf, contract.functions.worker_balance_limit().call())
    user_balance_limit = to_cpc(cf, contract.functions.user_balance_limit().call())
    tx_upper_limit = to_cpc(cf, contract.functions.tx_upper_limit().call())
    tx_lower_limit = to_cpc(cf, contract.functions.tx_lower_limit().call())
    withdraw_upper_limit = to_cpc(cf, contract.functions.withdraw_upper_limit().call())
    print('=' * 20)
    print("Enable:", enable)
    print("Withdraw Fee Numerator:", withdraw_fee_numerator)
    print("Withdraw Fee Denominator:", withdraw_fee_denominator)
    print("Worker Balance Limit:", worker_balance_limit, 'CPC')
    print("User Balance Limit:", user_balance_limit, 'CPC')
    print("Tx Upper Limit:", tx_upper_limit, 'CPC')
    print("Tx Lower Limit:", tx_lower_limit, 'CPC')
    print("Withdraw Upper Limit:", withdraw_upper_limit, 'CPC')
    print('=' * 20)
    print("Worker's cnt:", contract.functions.workersCnt().call())
    print('=' * 20)
    print("Total balance:", to_cpc(cf, contract.functions.total_balance().call()), 'CPC')



def add_worker(args):
    """ Add a worker
    """
    cf = get_cf(args)
    instance = get_instance(cf, args)
    worker_addr = cf.toChecksumAddress(args.worker)
    gas_price = cf.cpc.gasPrice

    ks, addr = load_keystore(cf, args)

    nonce = cf.cpc.getTransactionCount(addr)
    tx = instance.functions.addWorker(worker_addr).buildTransaction({
        'gasPrice': gas_price,
        "nonce": nonce,
        "gas": 300000,
        "from": addr,
        "value": 0,
        "type": 0,
        "chainId": 337
    })
    submit_tx(cf, ks, tx)


def remove_worker(args):
    """ Remove a worker
    """
    cf = get_cf(args)
    instance = get_instance(cf, args)
    worker_addr = cf.toChecksumAddress(args.worker)
    gas_price = cf.cpc.gasPrice

    ks, addr = load_keystore(cf, args)

    nonce = cf.cpc.getTransactionCount(addr)
    tx = instance.functions.removeWorker(worker_addr).buildTransaction({
        'gasPrice': gas_price,
        "nonce": nonce,
        "gas": 300000,
        "from": addr,
        "value": 0,
        "type": 0,
        "chainId": 337
    })
    submit_tx(cf, ks, tx)


def is_worker(args):
    cf = get_cf(args)
    contract = get_instance(cf, args)
    worker_addr = cf.toChecksumAddress(args.worker)
    b = contract.functions.isWorker(worker_addr).call()
    log.info(f"This address is worker: {b}")


def list_workers(args):
    cf = get_cf(args)
    instance = get_instance(cf, args)
    # add worker
    events = instance.events[EVENT_ADD_WORKER]().createFilter(
        fromBlock=context.fromBlock).get_all_entries()
    workers = []
    for e in events:
        workers.append({
            'address': e['args']['account'],
            'number': e['blockNumber']
        })
    
    # remove worker
    events = instance.events[EVENT_REMOVE_WORKER]().createFilter(
        fromBlock=context.fromBlock).get_all_entries()
    for e in events:
        for w in workers:
            if e['args']['account'] == w['address'] and e['blockNumber'] > w['number']:
                workers.remove(w)

    for w in workers:
        balance = cf.cpc.getBalance(w['address'])
        balance = cf.fromWei(balance, 'ether')
        log.info(f'{w["address"]}: {balance}')


def stats_interest(args):
    pass


def appeal_refund(args):
    pass


def monitoring(args):
    """
    Monitoring the event for appeal
    """
    pass


def build_parser(subparsers, name, func=None, helps="Help", keystore=False,
                 contract_file=False, endpoint=False):
    parser = subparsers.add_parser(name, help=helps)
    if keystore:
        parser.add_argument('--keystore', required=True)
    if contract_file:
        parser.add_argument('--contract-file', required=True)
    if endpoint:
        parser.add_argument('--endpoint', type=str, default=DEFAULT_ENDPOINT)
    parser.set_defaults(func=func)
    return parser


subparsers = parser.add_subparsers(help="sub-command help")

# deploy
build_parser(subparsers, 'deploy', deploy, 'deploy contract',
             keystore=True, contract_file=True, endpoint=True)

# show-configs
build_parser(subparsers, 'show-configs', show_configs, 'show configurations',
             contract_file=True, endpoint=True)

# add-worker
add_worker_parser = build_parser(subparsers, 'add-worker', func=add_worker, helps='add worker', keystore=True,
                                 contract_file=True, endpoint=True)
add_worker_parser.add_argument('worker', type=str)

# remove worker
remove_worker_parser = build_parser(subparsers, 'remove-worker', func=remove_worker, helps='remove worker', keystore=True,
                                    contract_file=True, endpoint=True)
remove_worker_parser.add_argument('worker', type=str)

# is worker
is_worker_parser = build_parser(subparsers, 'is-worker', func=is_worker, helps='whether a address is a worker',
                                contract_file=True, endpoint=True)
is_worker_parser.add_argument('worker', type=str)

# list workers
list_workers_parser = build_parser(subparsers, 'list-workers', func=list_workers, helps='List workers', contract_file=True,
                                   endpoint=True)

args = parser.parse_args()

if len(args.__dict__) <= 1:
    # No arguments or subcommands were given.
    parser.print_help()
    parser.exit()

args.func(args)

# overwrite context
def save(context):
    with open(FILE_NAME, 'w') as f:
        f.write(json.dumps(context))


save(context)
